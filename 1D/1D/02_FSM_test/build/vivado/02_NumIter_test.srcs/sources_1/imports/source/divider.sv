/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module divider #(
        parameter SIZE = 6'h20
    ) (
        input wire [(SIZE)-1:0] a,
        input wire [(SIZE)-1:0] b,
        input wire [0:0] alufn,
        output reg [(SIZE * 2'h2)-1:0] out,
        output reg [(SIZE)-1:0] rem
    );
    logic [31:0] R_5e2d0699_i;
    logic [31:0] RR_5e2d0699_i;
    logic [31:0] R_6ca3acea_i;
    logic [31:0] RR_6ca3acea_i;
    logic [(SIZE)-1:0][(SIZE)-1:0] remReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] quoReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] shifted_remReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] shifted_quoReg;
    logic [(SIZE)-1:0] final_remReg;
    logic [(SIZE)-1:0] final_quoReg;
    logic [(SIZE)-1:0][(SIZE * 2'h2)-1:0] temp;
    localparam _MP_SIZE_51724902 = SIZE;
    logic [(_MP_SIZE_51724902)-1:0][(_MP_SIZE_51724902)-1:0] M_adder_a;
    logic [(_MP_SIZE_51724902)-1:0][(_MP_SIZE_51724902)-1:0] M_adder_b;
    logic [(_MP_SIZE_51724902)-1:0][0:0] M_adder_alufn;
    logic [(_MP_SIZE_51724902)-1:0][(_MP_SIZE_51724902)-1:0] M_adder_out;
    logic [(_MP_SIZE_51724902)-1:0] M_adder_zero_flag;
    logic [(_MP_SIZE_51724902)-1:0] M_adder_overflow_flag;
    logic [(_MP_SIZE_51724902)-1:0] M_adder_negative_flag;
    
    genvar idx_0_51724902;
    
    generate
        for (idx_0_51724902 = 0; idx_0_51724902 < _MP_SIZE_51724902; idx_0_51724902 = idx_0_51724902 + 1) begin: forLoop_idx_0_51724902
            adder #(
                .SIZE(_MP_SIZE_51724902)
            ) adder (
                .a(M_adder_a[idx_0_51724902]),
                .b(M_adder_b[idx_0_51724902]),
                .alufn(M_adder_alufn[idx_0_51724902]),
                .out(M_adder_out[idx_0_51724902]),
                .zero_flag(M_adder_zero_flag[idx_0_51724902]),
                .overflow_flag(M_adder_overflow_flag[idx_0_51724902]),
                .negative_flag(M_adder_negative_flag[idx_0_51724902])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_1301514115 = SIZE * 2'h2;
    logic [(_MP_SIZE_1301514115)-1:0][(_MP_SIZE_1301514115)-1:0] M_shiftL_a;
    logic [(_MP_SIZE_1301514115)-1:0][4:0] M_shiftL_shift;
    logic [(_MP_SIZE_1301514115)-1:0][(_MP_SIZE_1301514115)-1:0] M_shiftL_result;
    
    genvar idx_0_1301514115;
    
    generate
        for (idx_0_1301514115 = 0; idx_0_1301514115 < _MP_SIZE_1301514115; idx_0_1301514115 = idx_0_1301514115 + 1) begin: forLoop_idx_0_1301514115
            shifter_BitL #(
                .SIZE(_MP_SIZE_1301514115)
            ) shiftL (
                .a(M_shiftL_a[idx_0_1301514115]),
                .shift(M_shiftL_shift[idx_0_1301514115]),
                .result(M_shiftL_result[idx_0_1301514115])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_197463817 = SIZE;
    logic [(_MP_SIZE_197463817)-1:0] M_finalAdd_a;
    logic [(_MP_SIZE_197463817)-1:0] M_finalAdd_out;
    logic M_finalAdd_zero_flag;
    logic M_finalAdd_overflow_flag;
    logic M_finalAdd_negative_flag;
    
    adder #(
        .SIZE(_MP_SIZE_197463817)
    ) finalAdd (
        .alufn(1'h0),
        .b(b),
        .a(M_finalAdd_a),
        .out(M_finalAdd_out),
        .zero_flag(M_finalAdd_zero_flag),
        .overflow_flag(M_finalAdd_overflow_flag),
        .negative_flag(M_finalAdd_negative_flag)
    );
    
    
    always @* begin
        for (RR_5e2d0699_i = 0; RR_5e2d0699_i < SIZE; RR_5e2d0699_i = RR_5e2d0699_i + 1) begin
      R_5e2d0699_i = (0) + RR_5e2d0699_i * (1);
            remReg[R_5e2d0699_i] = 1'h0;
            quoReg[R_5e2d0699_i] = 1'h0;
            temp[R_5e2d0699_i] = 1'h0;
            M_shiftL_a[R_5e2d0699_i] = 1'h0;
            M_adder_a[R_5e2d0699_i] = 1'h0;
            M_adder_b[R_5e2d0699_i] = b;
            M_adder_alufn[R_5e2d0699_i] = 1'h0;
            shifted_remReg[R_5e2d0699_i] = 1'h0;
            shifted_quoReg[R_5e2d0699_i] = 1'h0;
        end
        final_remReg = 1'h0;
        final_quoReg = 1'h0;
        M_finalAdd_a = 1'h0;
        out = 1'h0;
        rem = 1'h0;
        quoReg[1'h0] = a;
        remReg[1'h0] = {SIZE{1'h0}};
        for (RR_6ca3acea_i = 0; RR_6ca3acea_i < SIZE; RR_6ca3acea_i = RR_6ca3acea_i + 1) begin
      R_6ca3acea_i = (0) + RR_6ca3acea_i * (1);
            temp[R_6ca3acea_i] = {remReg[R_6ca3acea_i], quoReg[R_6ca3acea_i]};
            M_shiftL_shift[R_6ca3acea_i] = 5'h1;
            M_shiftL_a[R_6ca3acea_i] = temp[R_6ca3acea_i];
            shifted_remReg[R_6ca3acea_i] = M_shiftL_result[R_6ca3acea_i][2'h2 * SIZE - 1'h1:SIZE];
            shifted_quoReg[R_6ca3acea_i] = M_shiftL_result[R_6ca3acea_i][SIZE - 1'h1:1'h1];
            M_adder_a[R_6ca3acea_i] = shifted_remReg[R_6ca3acea_i];
            if (shifted_remReg[R_6ca3acea_i][SIZE - 1'h1] == 1'h0) begin
                M_adder_alufn[R_6ca3acea_i] = 1'h1;
            end else begin
                M_adder_alufn[R_6ca3acea_i] = 1'h0;
            end
            if (R_6ca3acea_i < SIZE - 1'h1) begin
                remReg[R_6ca3acea_i + 1'h1] = M_adder_out[R_6ca3acea_i];
                quoReg[R_6ca3acea_i + 1'h1] = (remReg[R_6ca3acea_i + 1'h1][SIZE - 1'h1] == 1'h0) ? {shifted_quoReg[R_6ca3acea_i], 1'h1} : {shifted_quoReg[R_6ca3acea_i], 1'h0};
            end else begin
                if (M_adder_out[R_6ca3acea_i][SIZE - 1'h1] == 1'h1) begin
                    M_finalAdd_a = M_adder_out[R_6ca3acea_i];
                    final_remReg = M_finalAdd_out;
                end else begin
                    final_remReg = M_adder_out[SIZE - 1'h1];
                end
                final_quoReg = (M_adder_out[R_6ca3acea_i][SIZE - 1'h1] == 1'h0) ? {shifted_quoReg[R_6ca3acea_i], 1'h1} : {shifted_quoReg[R_6ca3acea_i], 1'h0};
            end
        end
        out = alufn ? final_quoReg : 1'h0;
        rem = final_remReg;
    end
    
    
endmodule