/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module alchitry_top (
        input wire clk,
        input wire rst_n,
        output reg [7:0] led,
        input wire usb_rx,
        output reg usb_tx,
        output reg [2:0][7:0] io_led,
        output reg [7:0] io_segment,
        output reg [3:0] io_select,
        output reg data,
        input wire [4:0] io_button,
        input wire [2:0][7:0] io_dip
    );
    logic rst;
    localparam CLK_FREQ = 27'h5f5e100;
    logic [1:0][3:0] highScore_seg;
    localparam E_States_IDLE = 3'h0;
    localparam E_States_START = 3'h1;
    localparam E_States_NEXTNUM = 3'h2;
    localparam E_States_ADDSCORE = 3'h3;
    localparam E_States_SCORECMP = 3'h4;
    localparam _MP_STAGES_1993974559 = 3'h4;
    logic M_reset_cond_in;
    logic M_reset_cond_out;
    
    reset_conditioner #(
        .STAGES(_MP_STAGES_1993974559)
    ) reset_cond (
        .clk(clk),
        .in(M_reset_cond_in),
        .out(M_reset_cond_out)
    );
    
    
    localparam _MP_RISE_1763147972 = 1'h1;
    localparam _MP_FALL_1763147972 = 1'h0;
    logic M_pulseEdge_in;
    logic M_pulseEdge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1763147972),
        .FALL(_MP_FALL_1763147972)
    ) pulseEdge (
        .clk(clk),
        .in(M_pulseEdge_in),
        .out(M_pulseEdge_out)
    );
    
    
    localparam _MP_CLK_FREQ_1574675243 = 27'h5f5e100;
    localparam _MP_MIN_DELAY_1574675243 = 5'h14;
    localparam _MP_NUM_SYNC_1574675243 = 2'h2;
    logic M_start_cond_out;
    
    button_conditioner #(
        .CLK_FREQ(_MP_CLK_FREQ_1574675243),
        .MIN_DELAY(_MP_MIN_DELAY_1574675243),
        .NUM_SYNC(_MP_NUM_SYNC_1574675243)
    ) start_cond (
        .in(io_button[3'h4]),
        .clk(clk),
        .out(M_start_cond_out)
    );
    
    
    localparam _MP_RISE_1363284565 = 1'h1;
    localparam _MP_FALL_1363284565 = 1'h0;
    logic M_start_edge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1363284565),
        .FALL(_MP_FALL_1363284565)
    ) start_edge (
        .in(M_start_cond_out),
        .clk(clk),
        .out(M_start_edge_out)
    );
    
    
    localparam _MP_DIGITS_1033784687 = 3'h6;
    localparam _MP_DIV_1033784687 = 5'h10;
    logic [5:0][3:0] M_seg_values;
    logic [6:0] M_seg_seg;
    logic [5:0] M_seg_sel;
    
    multi_seven_seg #(
        .DIGITS(_MP_DIGITS_1033784687),
        .DIV(_MP_DIV_1033784687)
    ) seg (
        .clk(clk),
        .rst(rst),
        .values(M_seg_values),
        .seg(M_seg_seg),
        .sel(M_seg_sel)
    );
    
    
    localparam _MP_DIGITS_1861886170 = 2'h2;
    localparam _MP_MODE_1861886170 = 1'h1;
    logic M_timer_inc;
    logic [1:0][3:0] M_timer_start;
    logic [1:0][3:0] M_timer_digits;
    
    multi_decimal_counter #(
        .DIGITS(_MP_DIGITS_1861886170),
        .MODE(_MP_MODE_1861886170)
    ) timer (
        .limit({{4'h0, 4'h0}}),
        .clk(clk),
        .rst(rst),
        .inc(M_timer_inc),
        .start(M_timer_start),
        .digits(M_timer_digits)
    );
    
    
    localparam _MP_DIGITS_1820102250 = 2'h2;
    localparam _MP_MODE_1820102250 = 1'h0;
    logic M_pts_ctr_inc;
    logic [1:0][3:0] M_pts_ctr_digits;
    
    multi_decimal_counter #(
        .DIGITS(_MP_DIGITS_1820102250),
        .MODE(_MP_MODE_1820102250)
    ) pts_ctr (
        .start({{4'h0, 4'h0}}),
        .limit({{4'h9, 4'h9}}),
        .clk(clk),
        .rst(rst),
        .inc(M_pts_ctr_inc),
        .digits(M_pts_ctr_digits)
    );
    
    
    localparam _MP_SIZE_2037695123 = 1'h1;
    localparam _MP_DIV_2037695123 = 5'h18;
    localparam _MP_TOP_2037695123 = 1'h0;
    localparam _MP_UP_2037695123 = 1'h1;
    logic [0:0] M_pulse_value;
    
    counter #(
        .SIZE(_MP_SIZE_2037695123),
        .DIV(_MP_DIV_2037695123),
        .TOP(_MP_TOP_2037695123),
        .UP(_MP_UP_2037695123)
    ) pulse (
        .clk(clk),
        .rst(rst),
        .value(M_pulse_value)
    );
    
    
    logic [2:0] D_states_d, D_states_q = 3'h0;
    logic [7:0] D_currScore_d, D_currScore_q = 1'h0;
    logic [7:0] D_highScore_d, D_highScore_q = 1'h0;
    logic [0:0] D_startTimeEnable_d, D_startTimeEnable_q = 1'h0;
    logic [1:0] D_nextNumEnable_d, D_nextNumEnable_q = 1'h0;
    logic [2:0] M_inpCtr_currVal;
    logic M_inpCtr_validOut;
    
    input_controller inpCtr (
        .clk(clk),
        .rst_n(rst),
        .io_button(io_button),
        .currVal(M_inpCtr_currVal),
        .validOut(M_inpCtr_validOut)
    );
    
    
    logic M_numGen_in;
    logic [1:0] M_numGen_out;
    
    number_generator numGen (
        .clk(clk),
        .rst_n(rst),
        .in(M_numGen_in),
        .out(M_numGen_out)
    );
    
    
    localparam _MP_SIZE_364090087 = 4'h8;
    logic [7:0] M_alu_a;
    logic [7:0] M_alu_b;
    logic M_alu_z;
    logic M_alu_v;
    logic M_alu_n;
    logic [7:0] M_alu_out;
    
    alu #(
        .SIZE(_MP_SIZE_364090087)
    ) alu (
        .alufn(6'h35),
        .a(M_alu_a),
        .b(M_alu_b),
        .z(M_alu_z),
        .v(M_alu_v),
        .n(M_alu_n),
        .out(M_alu_out)
    );
    
    
    localparam _MP_COLUMN_DIMENSION_510749726 = 3'h4;
    localparam _MP_ROW_DIMENSION_510749726 = 1'h1;
    localparam _MP_PIXEL_COUNT_510749726 = 3'h4;
    localparam _MP_BUFFER_SIZE_510749726 = 4'hc;
    logic [2:0] M_colourCtr_selColour;
    logic M_colourCtr_data;
    
    toggle_mode #(
        .COLUMN_DIMENSION(_MP_COLUMN_DIMENSION_510749726),
        .ROW_DIMENSION(_MP_ROW_DIMENSION_510749726),
        .PIXEL_COUNT(_MP_PIXEL_COUNT_510749726),
        .BUFFER_SIZE(_MP_BUFFER_SIZE_510749726)
    ) colourCtr (
        .clk(clk),
        .rst_n(rst),
        .selColour(M_colourCtr_selColour),
        .data(M_colourCtr_data)
    );
    
    
    always @* begin
        D_states_d = D_states_q;
        D_startTimeEnable_d = D_startTimeEnable_q;
        D_nextNumEnable_d = D_nextNumEnable_q;
        D_currScore_d = D_currScore_q;
        D_highScore_d = D_highScore_q;
        
        M_reset_cond_in = ~rst_n;
        rst = M_reset_cond_out;
        led = {3'h0, io_button};
        usb_tx = usb_rx;
        D_states_d = D_states_q;
        D_startTimeEnable_d = D_startTimeEnable_q;
        D_nextNumEnable_d = D_nextNumEnable_q;
        M_pulseEdge_in = M_pulse_value;
        highScore_seg = {{4'h0, 4'h0}};
        M_alu_a = 1'h0;
        M_alu_b = 1'h0;
        data = M_colourCtr_data;
        M_timer_start = {{4'h0, 4'h0}};
        M_timer_inc = 1'h0;
        M_pts_ctr_inc = 1'h0;
        M_numGen_in = 1'h0;
        M_inpCtr_currVal = 3'h5;
        M_colourCtr_selColour = 3'h5;
        
        case (D_states_q)
            3'h0: begin
                if (M_start_edge_out) begin
                    D_states_d = 3'h1;
                end
                if (M_inpCtr_validOut && (|M_timer_digits)) begin
                    D_states_d = 3'h2;
                    D_nextNumEnable_d = 1'h1;
                end
                if (~(|M_timer_digits)) begin
                    D_states_d = 3'h4;
                end
            end
            3'h1: begin
                D_currScore_d = 1'h0;
                M_timer_start = {{4'h3, 4'h0}};
                D_startTimeEnable_d = 1'h1;
                D_states_d = 3'h0;
            end
            3'h2: begin
                if (D_nextNumEnable_q == 1'h1) begin
                    M_numGen_in = M_pulseEdge_out;
                    D_nextNumEnable_d = 2'h2;
                end
                M_inpCtr_currVal = M_numGen_out;
                M_colourCtr_selColour = M_numGen_out;
                D_states_d = 3'h3;
            end
            3'h3: begin
                if (D_nextNumEnable_q == 2'h2) begin
                    M_pts_ctr_inc = M_pulseEdge_out;
                    D_nextNumEnable_d = 1'h0;
                end
                D_currScore_d = M_pts_ctr_digits;
                D_states_d = 3'h0;
            end
            3'h4: begin
                D_startTimeEnable_d = 1'h0;
                M_alu_a = D_highScore_q;
                M_alu_b = D_currScore_q;
                if (M_alu_out == 1'h1) begin
                    D_highScore_d = D_currScore_q;
                    highScore_seg = M_pts_ctr_digits;
                end
                D_states_d = 3'h0;
            end
        endcase
        if (D_startTimeEnable_q == 1'h1) begin
            M_timer_inc = M_pulseEdge_out;
        end
        M_seg_values = {highScore_seg, M_timer_digits, M_pts_ctr_digits};
        io_segment = M_seg_seg;
        io_select = M_seg_sel;
        io_led = io_dip;
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_states_q <= 3'h0;
            D_currScore_q <= 1'h0;
            D_highScore_q <= 1'h0;
            D_startTimeEnable_q <= 1'h0;
            D_nextNumEnable_q <= 1'h0;
        end else begin
            D_states_q <= D_states_d;
            D_currScore_q <= D_currScore_d;
            D_highScore_q <= D_highScore_d;
            D_startTimeEnable_q <= D_startTimeEnable_d;
            D_nextNumEnable_q <= D_nextNumEnable_d;
        end
    end
endmodule