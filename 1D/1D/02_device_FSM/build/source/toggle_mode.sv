/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module toggle_mode #(
        parameter COLUMN_DIMENSION = 3'h4,
        parameter ROW_DIMENSION = 1'h1,
        parameter PIXEL_COUNT = 3'h4,
        parameter BUFFER_SIZE = 4'hc
    ) (
        input wire clk,
        input wire rst_n,
        input wire [2:0] selColour,
        output reg data
    );
    localparam logic [4:0][23:0] COLOR_ENCODING = {{24'hff0000, 24'hff, 24'hff00, 24'h82eeee, 24'hffffff}};
    logic [(BUFFER_SIZE)-1:0] pixel_address;
    logic [3:0][2:0] colour;
    logic rst;
    localparam CLK_FREQ = 27'h5f5e100;
    localparam _MP_STAGES_88166810 = 3'h4;
    logic M_reset_cond_in;
    logic M_reset_cond_out;
    
    reset_conditioner #(
        .STAGES(_MP_STAGES_88166810)
    ) reset_cond (
        .clk(clk),
        .in(M_reset_cond_in),
        .out(M_reset_cond_out)
    );
    
    
    logic [0:0] D_pulseCount_d, D_pulseCount_q = 1'h1;
    localparam logic [3:0][2:0] GREEN = {{3'h4, 3'h4, 3'h4, 3'h4}};
    localparam logic [3:0][2:0] BLUE = {{3'h3, 3'h3, 3'h3, 3'h3}};
    localparam logic [3:0][2:0] RED = {{3'h2, 3'h2, 3'h2, 3'h2}};
    localparam logic [3:0][2:0] YELLOW = {{3'h1, 3'h1, 3'h1, 3'h1}};
    localparam logic [3:0][2:0] WHITE = {{3'h0, 3'h0, 3'h0, 3'h0}};
    localparam _MP_PIXEL_COUNT_1930562337 = PIXEL_COUNT;
    logic M_driver_update;
    logic [23:0] M_driver_color;
    logic M_driver_clear;
    logic [($clog2(_MP_PIXEL_COUNT_1930562337))-1:0] M_driver_pixel_address;
    logic M_driver_data;
    logic M_driver_next_pixel;
    logic M_driver_reset;
    logic M_driver_done;
    
    ws2812b_driver #(
        .PIXEL_COUNT(_MP_PIXEL_COUNT_1930562337)
    ) driver (
        .rst(rst),
        .clk(clk),
        .update(M_driver_update),
        .color(M_driver_color),
        .clear(M_driver_clear),
        .pixel_address(M_driver_pixel_address),
        .data(M_driver_data),
        .next_pixel(M_driver_next_pixel),
        .reset(M_driver_reset),
        .done(M_driver_done)
    );
    
    
    always @* begin
        D_pulseCount_d = D_pulseCount_q;
        
        M_reset_cond_in = ~rst_n;
        rst = M_reset_cond_out;
        D_pulseCount_d = D_pulseCount_q;
        data = 1'h0;
        M_driver_update = 1'h0;
        M_driver_clear = 1'h0;
        pixel_address = M_driver_pixel_address;
        
        case (selColour)
            3'h0: begin
                colour = {{3'h2, 3'h2, 3'h2, 3'h2}};
                D_pulseCount_d = 1'h0;
            end
            3'h1: begin
                colour = {{3'h4, 3'h4, 3'h4, 3'h4}};
                D_pulseCount_d = 1'h0;
            end
            3'h2: begin
                colour = {{3'h3, 3'h3, 3'h3, 3'h3}};
                D_pulseCount_d = 1'h0;
            end
            3'h3: begin
                colour = {{3'h1, 3'h1, 3'h1, 3'h1}};
                D_pulseCount_d = 1'h0;
            end
            default: begin
                colour = {{3'h0, 3'h0, 3'h0, 3'h0}};
                D_pulseCount_d = 1'h0;
            end
        endcase
        M_driver_color = COLOR_ENCODING[colour[pixel_address]];
        data = M_driver_data;
        if (D_pulseCount_q == 1'h0) begin
            M_driver_update = 1'h1;
        end
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_pulseCount_q <= 1'h1;
        end else begin
            D_pulseCount_q <= D_pulseCount_d;
        end
    end
endmodule