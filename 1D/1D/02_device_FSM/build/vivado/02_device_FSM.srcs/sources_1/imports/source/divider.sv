/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module divider #(
        parameter SIZE = 6'h20
    ) (
        input wire [(SIZE)-1:0] a,
        input wire [(SIZE)-1:0] b,
        input wire [0:0] alufn,
        output reg [(SIZE)-1:0] out,
        output reg [(SIZE)-1:0] rem
    );
    logic [31:0] R_7b2dad99_i;
    logic [31:0] RR_7b2dad99_i;
    logic [31:0] R_32783b07_i;
    logic [31:0] RR_32783b07_i;
    logic [(SIZE)-1:0][(SIZE)-1:0] remReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] quoReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] shifted_remReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] shifted_quoReg;
    logic [(SIZE)-1:0] final_remReg;
    logic [(SIZE)-1:0] final_quoReg;
    logic [(SIZE)-1:0][(SIZE * 2'h2)-1:0] temp;
    localparam _MP_SIZE_54508433 = SIZE;
    logic [(_MP_SIZE_54508433)-1:0][(_MP_SIZE_54508433)-1:0] M_adder_a;
    logic [(_MP_SIZE_54508433)-1:0][(_MP_SIZE_54508433)-1:0] M_adder_b;
    logic [(_MP_SIZE_54508433)-1:0][0:0] M_adder_alufn;
    logic [(_MP_SIZE_54508433)-1:0][(_MP_SIZE_54508433)-1:0] M_adder_out;
    logic [(_MP_SIZE_54508433)-1:0] M_adder_zero_flag;
    logic [(_MP_SIZE_54508433)-1:0] M_adder_overflow_flag;
    logic [(_MP_SIZE_54508433)-1:0] M_adder_negative_flag;
    
    genvar idx_0_54508433;
    
    generate
        for (idx_0_54508433 = 0; idx_0_54508433 < _MP_SIZE_54508433; idx_0_54508433 = idx_0_54508433 + 1) begin: forLoop_idx_0_54508433
            adder #(
                .SIZE(_MP_SIZE_54508433)
            ) adder (
                .a(M_adder_a[idx_0_54508433]),
                .b(M_adder_b[idx_0_54508433]),
                .alufn(M_adder_alufn[idx_0_54508433]),
                .out(M_adder_out[idx_0_54508433]),
                .zero_flag(M_adder_zero_flag[idx_0_54508433]),
                .overflow_flag(M_adder_overflow_flag[idx_0_54508433]),
                .negative_flag(M_adder_negative_flag[idx_0_54508433])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_1717876287 = SIZE;
    logic [(_MP_SIZE_1717876287)-1:0] M_finalAdd_a;
    logic [(_MP_SIZE_1717876287)-1:0] M_finalAdd_out;
    logic M_finalAdd_zero_flag;
    logic M_finalAdd_overflow_flag;
    logic M_finalAdd_negative_flag;
    
    adder #(
        .SIZE(_MP_SIZE_1717876287)
    ) finalAdd (
        .alufn(1'h0),
        .b(b),
        .a(M_finalAdd_a),
        .out(M_finalAdd_out),
        .zero_flag(M_finalAdd_zero_flag),
        .overflow_flag(M_finalAdd_overflow_flag),
        .negative_flag(M_finalAdd_negative_flag)
    );
    
    
    always @* begin
        for (RR_7b2dad99_i = 0; RR_7b2dad99_i < SIZE; RR_7b2dad99_i = RR_7b2dad99_i + 1) begin
      R_7b2dad99_i = (0) + RR_7b2dad99_i * (1);
            remReg[R_7b2dad99_i] = 1'h0;
            quoReg[R_7b2dad99_i] = 1'h0;
            temp[R_7b2dad99_i] = 1'h0;
            M_adder_a[R_7b2dad99_i] = 1'h0;
            M_adder_b[R_7b2dad99_i] = b;
            M_adder_alufn[R_7b2dad99_i] = 1'h0;
            shifted_remReg[R_7b2dad99_i] = 1'h0;
            shifted_quoReg[R_7b2dad99_i] = 1'h0;
        end
        final_remReg = 1'h0;
        final_quoReg = 1'h0;
        M_finalAdd_a = 1'h0;
        out = 1'h0;
        rem = 1'h0;
        quoReg[1'h0] = a;
        remReg[1'h0] = {SIZE{1'h0}};
        for (RR_32783b07_i = 0; RR_32783b07_i < SIZE; RR_32783b07_i = RR_32783b07_i + 1) begin
      R_32783b07_i = (0) + RR_32783b07_i * (1);
            temp[R_32783b07_i] = {remReg[R_32783b07_i][SIZE - 2'h2:1'h0], quoReg[R_32783b07_i], 1'h0};
            shifted_remReg[R_32783b07_i] = temp[R_32783b07_i][2'h2 * SIZE - 1'h1:SIZE];
            shifted_quoReg[R_32783b07_i] = temp[R_32783b07_i][SIZE - 1'h1:1'h1];
            M_adder_a[R_32783b07_i] = shifted_remReg[R_32783b07_i];
            if (shifted_remReg[R_32783b07_i][SIZE - 1'h1] == 1'h0) begin
                M_adder_alufn[R_32783b07_i] = 1'h1;
            end else begin
                M_adder_alufn[R_32783b07_i] = 1'h0;
            end
            if (R_32783b07_i < SIZE - 1'h1) begin
                remReg[R_32783b07_i + 1'h1] = M_adder_out[R_32783b07_i];
                quoReg[R_32783b07_i + 1'h1] = (remReg[R_32783b07_i + 1'h1][SIZE - 1'h1] == 1'h0) ? {shifted_quoReg[R_32783b07_i], 1'h1} : {shifted_quoReg[R_32783b07_i], 1'h0};
            end else begin
                if (M_adder_out[R_32783b07_i][SIZE - 1'h1] == 1'h1) begin
                    M_finalAdd_a = M_adder_out[R_32783b07_i];
                    final_remReg = M_finalAdd_out;
                end else begin
                    final_remReg = M_adder_out[R_32783b07_i];
                end
                final_quoReg = (M_adder_out[R_32783b07_i][SIZE - 1'h1] == 1'h0) ? {shifted_quoReg[R_32783b07_i], 1'h1} : {shifted_quoReg[R_32783b07_i], 1'h0};
            end
        end
        out = alufn ? final_quoReg : 1'h0;
        rem = final_remReg;
    end
    
    
endmodule