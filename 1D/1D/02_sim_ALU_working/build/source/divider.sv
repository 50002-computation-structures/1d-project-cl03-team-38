/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module divider #(
        parameter SIZE = 6'h20
    ) (
        input wire [(SIZE)-1:0] a,
        input wire [(SIZE)-1:0] b,
        input wire [0:0] alufn,
        output reg [(SIZE)-1:0] out,
        output reg [(SIZE)-1:0] rem
    );
    logic [31:0] R_06f25d00_i;
    logic [31:0] RR_06f25d00_i;
    logic [31:0] R_16a172ac_i;
    logic [31:0] RR_16a172ac_i;
    logic [(SIZE)-1:0][(SIZE)-1:0] remReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] quoReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] shifted_remReg;
    logic [(SIZE)-1:0][(SIZE)-1:0] shifted_quoReg;
    logic [(SIZE)-1:0] final_remReg;
    logic [(SIZE)-1:0] final_quoReg;
    logic [(SIZE)-1:0][(SIZE * 2'h2)-1:0] temp;
    localparam _MP_SIZE_2020864571 = SIZE;
    logic [(_MP_SIZE_2020864571)-1:0][(_MP_SIZE_2020864571)-1:0] M_adder_a;
    logic [(_MP_SIZE_2020864571)-1:0][(_MP_SIZE_2020864571)-1:0] M_adder_b;
    logic [(_MP_SIZE_2020864571)-1:0][0:0] M_adder_alufn;
    logic [(_MP_SIZE_2020864571)-1:0][(_MP_SIZE_2020864571)-1:0] M_adder_out;
    logic [(_MP_SIZE_2020864571)-1:0] M_adder_zero_flag;
    logic [(_MP_SIZE_2020864571)-1:0] M_adder_overflow_flag;
    logic [(_MP_SIZE_2020864571)-1:0] M_adder_negative_flag;
    
    genvar idx_0_2020864571;
    
    generate
        for (idx_0_2020864571 = 0; idx_0_2020864571 < _MP_SIZE_2020864571; idx_0_2020864571 = idx_0_2020864571 + 1) begin: forLoop_idx_0_2020864571
            adder #(
                .SIZE(_MP_SIZE_2020864571)
            ) adder (
                .a(M_adder_a[idx_0_2020864571]),
                .b(M_adder_b[idx_0_2020864571]),
                .alufn(M_adder_alufn[idx_0_2020864571]),
                .out(M_adder_out[idx_0_2020864571]),
                .zero_flag(M_adder_zero_flag[idx_0_2020864571]),
                .overflow_flag(M_adder_overflow_flag[idx_0_2020864571]),
                .negative_flag(M_adder_negative_flag[idx_0_2020864571])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_2128159232 = SIZE;
    logic [(_MP_SIZE_2128159232)-1:0] M_finalAdd_a;
    logic [(_MP_SIZE_2128159232)-1:0] M_finalAdd_out;
    logic M_finalAdd_zero_flag;
    logic M_finalAdd_overflow_flag;
    logic M_finalAdd_negative_flag;
    
    adder #(
        .SIZE(_MP_SIZE_2128159232)
    ) finalAdd (
        .alufn(1'h0),
        .b(b),
        .a(M_finalAdd_a),
        .out(M_finalAdd_out),
        .zero_flag(M_finalAdd_zero_flag),
        .overflow_flag(M_finalAdd_overflow_flag),
        .negative_flag(M_finalAdd_negative_flag)
    );
    
    
    always @* begin
        for (RR_06f25d00_i = 0; RR_06f25d00_i < SIZE; RR_06f25d00_i = RR_06f25d00_i + 1) begin
      R_06f25d00_i = (0) + RR_06f25d00_i * (1);
            remReg[R_06f25d00_i] = 1'h0;
            quoReg[R_06f25d00_i] = 1'h0;
            temp[R_06f25d00_i] = 1'h0;
            M_adder_a[R_06f25d00_i] = 1'h0;
            M_adder_b[R_06f25d00_i] = b;
            M_adder_alufn[R_06f25d00_i] = 1'h0;
            shifted_remReg[R_06f25d00_i] = 1'h0;
            shifted_quoReg[R_06f25d00_i] = 1'h0;
        end
        final_remReg = 1'h0;
        final_quoReg = 1'h0;
        M_finalAdd_a = 1'h0;
        out = 1'h0;
        rem = 1'h0;
        quoReg[1'h0] = a;
        remReg[1'h0] = {SIZE{1'h0}};
        for (RR_16a172ac_i = 0; RR_16a172ac_i < SIZE; RR_16a172ac_i = RR_16a172ac_i + 1) begin
      R_16a172ac_i = (0) + RR_16a172ac_i * (1);
            temp[R_16a172ac_i] = {remReg[R_16a172ac_i], quoReg[R_16a172ac_i]} << 1'h1;
            shifted_remReg[R_16a172ac_i] = temp[R_16a172ac_i][2'h2 * SIZE - 1'h1:SIZE];
            shifted_quoReg[R_16a172ac_i] = temp[R_16a172ac_i][SIZE - 1'h1:1'h1];
            M_adder_a[R_16a172ac_i] = shifted_remReg[R_16a172ac_i];
            if (shifted_remReg[R_16a172ac_i][SIZE - 1'h1] == 1'h0) begin
                M_adder_alufn[R_16a172ac_i] = 1'h1;
            end else begin
                M_adder_alufn[R_16a172ac_i] = 1'h0;
            end
            if (R_16a172ac_i < SIZE - 1'h1) begin
                remReg[R_16a172ac_i + 1'h1] = M_adder_out[R_16a172ac_i];
                quoReg[R_16a172ac_i + 1'h1] = (remReg[R_16a172ac_i + 1'h1][SIZE - 1'h1] == 1'h0) ? {shifted_quoReg[R_16a172ac_i], 1'h1} : {shifted_quoReg[R_16a172ac_i], 1'h0};
            end else begin
                if (M_adder_out[R_16a172ac_i][SIZE - 1'h1] == 1'h1) begin
                    M_finalAdd_a = M_adder_out[R_16a172ac_i];
                    final_remReg = M_finalAdd_out;
                end else begin
                    final_remReg = M_adder_out[R_16a172ac_i];
                end
                final_quoReg = (M_adder_out[R_16a172ac_i][SIZE - 1'h1] == 1'h0) ? {shifted_quoReg[R_16a172ac_i], 1'h1} : {shifted_quoReg[R_16a172ac_i], 1'h0};
            end
        end
        out = alufn ? final_quoReg : 1'h0;
        rem = final_remReg;
    end
    
    
endmodule