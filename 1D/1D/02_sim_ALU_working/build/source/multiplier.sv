/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module multiplier #(
        parameter SIZE = 6'h20
    ) (
        input wire [(SIZE)-1:0] a,
        input wire [(SIZE)-1:0] b,
        input wire [0:0] alufn,
        output reg [(SIZE)-1:0] out
    );
    logic [31:0] R_04eb1962_i;
    logic [31:0] RR_04eb1962_i;
    logic [31:0] R_04825bc5_i;
    logic [31:0] RR_04825bc5_i;
    logic [(SIZE)-1:0][(2'h2 * SIZE)-1:0] temp_accum;
    logic [(SIZE)-1:0][(2'h2 * SIZE)-1:0] accum;
    logic [(2'h2 * SIZE)-1:0] final_accum;
    logic [(SIZE)-1:0][(SIZE)-1:0] up_half;
    logic [(SIZE)-1:0][(SIZE)-1:0] low_half;
    logic [(SIZE)-1:0] old_lsb;
    localparam _MP_SIZE_893177767 = SIZE;
    logic [(_MP_SIZE_893177767)-1:0][(_MP_SIZE_893177767)-1:0] M_adder_a;
    logic [(_MP_SIZE_893177767)-1:0][(_MP_SIZE_893177767)-1:0] M_adder_b;
    logic [(_MP_SIZE_893177767)-1:0][0:0] M_adder_alufn;
    logic [(_MP_SIZE_893177767)-1:0][(_MP_SIZE_893177767)-1:0] M_adder_out;
    logic [(_MP_SIZE_893177767)-1:0] M_adder_zero_flag;
    logic [(_MP_SIZE_893177767)-1:0] M_adder_overflow_flag;
    logic [(_MP_SIZE_893177767)-1:0] M_adder_negative_flag;
    
    genvar idx_0_893177767;
    
    generate
        for (idx_0_893177767 = 0; idx_0_893177767 < _MP_SIZE_893177767; idx_0_893177767 = idx_0_893177767 + 1) begin: forLoop_idx_0_893177767
            adder #(
                .SIZE(_MP_SIZE_893177767)
            ) adder (
                .a(M_adder_a[idx_0_893177767]),
                .b(M_adder_b[idx_0_893177767]),
                .alufn(M_adder_alufn[idx_0_893177767]),
                .out(M_adder_out[idx_0_893177767]),
                .zero_flag(M_adder_zero_flag[idx_0_893177767]),
                .overflow_flag(M_adder_overflow_flag[idx_0_893177767]),
                .negative_flag(M_adder_negative_flag[idx_0_893177767])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_23429832 = 2'h2 * SIZE;
    logic [(_MP_SIZE_23429832)-1:0][(_MP_SIZE_23429832)-1:0] M_shiftR_a;
    logic [(_MP_SIZE_23429832)-1:0][4:0] M_shiftR_shift;
    logic [(_MP_SIZE_23429832)-1:0][(_MP_SIZE_23429832)-1:0] M_shiftR_result;
    
    genvar idx_0_23429832;
    
    generate
        for (idx_0_23429832 = 0; idx_0_23429832 < _MP_SIZE_23429832; idx_0_23429832 = idx_0_23429832 + 1) begin: forLoop_idx_0_23429832
            shifter_ArithBitR #(
                .SIZE(_MP_SIZE_23429832)
            ) shiftR (
                .a(M_shiftR_a[idx_0_23429832]),
                .shift(M_shiftR_shift[idx_0_23429832]),
                .result(M_shiftR_result[idx_0_23429832])
            );
        end
    endgenerate
    
    
    always @* begin
        for (RR_04eb1962_i = 0; RR_04eb1962_i < SIZE; RR_04eb1962_i = RR_04eb1962_i + 1) begin
      R_04eb1962_i = (0) + RR_04eb1962_i * (1);
            M_adder_a[R_04eb1962_i] = 1'h0;
            M_adder_b[R_04eb1962_i] = 1'h0;
            M_adder_alufn[R_04eb1962_i] = 1'h0;
            M_shiftR_a[R_04eb1962_i] = 1'h0;
            M_shiftR_shift[R_04eb1962_i] = 1'h0;
            accum[R_04eb1962_i] = 1'h0;
            up_half[R_04eb1962_i] = 1'h0;
            low_half[R_04eb1962_i] = 1'h0;
            old_lsb[R_04eb1962_i] = 1'h0;
            temp_accum[R_04eb1962_i] = 1'h0;
        end
        accum[1'h0] = {{SIZE{1'h0}}, a};
        old_lsb[1'h0] = 1'h0;
        for (RR_04825bc5_i = 0; RR_04825bc5_i < SIZE; RR_04825bc5_i = RR_04825bc5_i + 1) begin
      R_04825bc5_i = (0) + RR_04825bc5_i * (1);
            if (accum[R_04825bc5_i][1'h0] == 1'h0 && old_lsb[R_04825bc5_i] == 1'h1) begin
                M_adder_a[R_04825bc5_i] = accum[R_04825bc5_i][2'h2 * SIZE - 1'h1:SIZE];
                M_adder_b[R_04825bc5_i] = b;
                up_half[R_04825bc5_i] = M_adder_out[R_04825bc5_i];
            end else begin
                if (accum[R_04825bc5_i][1'h0] == 1'h1 && old_lsb[R_04825bc5_i] == 1'h0) begin
                    M_adder_a[R_04825bc5_i] = accum[R_04825bc5_i][2'h2 * SIZE - 1'h1:SIZE];
                    M_adder_b[R_04825bc5_i] = b;
                    M_adder_alufn[R_04825bc5_i] = 1'h1;
                    up_half[R_04825bc5_i] = M_adder_out[R_04825bc5_i];
                end else begin
                    up_half[R_04825bc5_i] = accum[R_04825bc5_i][2'h2 * SIZE - 1'h1:SIZE];
                end
            end
            low_half[R_04825bc5_i] = accum[R_04825bc5_i][SIZE - 1'h1:1'h0];
            temp_accum[R_04825bc5_i] = {up_half[R_04825bc5_i], low_half[R_04825bc5_i]};
            M_shiftR_a[R_04825bc5_i] = temp_accum[R_04825bc5_i];
            M_shiftR_shift[R_04825bc5_i] = 1'h1;
            if (R_04825bc5_i < SIZE - 1'h1) begin
                old_lsb[R_04825bc5_i + 1'h1] = accum[R_04825bc5_i][1'h0];
                accum[R_04825bc5_i + 1'h1] = M_shiftR_result[R_04825bc5_i];
            end else begin
                if (R_04825bc5_i == SIZE - 1'h1) begin
                    final_accum = M_shiftR_result[R_04825bc5_i];
                end
            end
        end
        out = alufn ? final_accum[SIZE - 1'h1:1'h0] : 1'h0;
    end
    
    
endmodule