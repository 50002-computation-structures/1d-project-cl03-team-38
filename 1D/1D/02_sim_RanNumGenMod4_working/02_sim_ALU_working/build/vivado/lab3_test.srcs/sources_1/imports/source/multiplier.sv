/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module multiplier #(
        parameter SIZE = 6'h20
    ) (
        input wire [(SIZE)-1:0] a,
        input wire [(SIZE)-1:0] b,
        input wire [0:0] alufn,
        output reg [(SIZE)-1:0] out
    );
    logic [31:0] R_5ee2e4f0_i;
    logic [31:0] RR_5ee2e4f0_i;
    logic [31:0] R_7ff2230f_i;
    logic [31:0] RR_7ff2230f_i;
    logic [(SIZE)-1:0][(2'h2 * SIZE)-1:0] temp_accum;
    logic [(SIZE)-1:0][(2'h2 * SIZE)-1:0] accum;
    logic [(2'h2 * SIZE)-1:0] final_accum;
    logic [(SIZE)-1:0][(SIZE)-1:0] up_half;
    logic [(SIZE)-1:0][(SIZE)-1:0] low_half;
    logic [(SIZE)-1:0] old_lsb;
    localparam _MP_SIZE_1939020140 = SIZE;
    logic [(_MP_SIZE_1939020140)-1:0][(_MP_SIZE_1939020140)-1:0] M_adder_a;
    logic [(_MP_SIZE_1939020140)-1:0][(_MP_SIZE_1939020140)-1:0] M_adder_b;
    logic [(_MP_SIZE_1939020140)-1:0][0:0] M_adder_alufn;
    logic [(_MP_SIZE_1939020140)-1:0][(_MP_SIZE_1939020140)-1:0] M_adder_out;
    logic [(_MP_SIZE_1939020140)-1:0] M_adder_zero_flag;
    logic [(_MP_SIZE_1939020140)-1:0] M_adder_overflow_flag;
    logic [(_MP_SIZE_1939020140)-1:0] M_adder_negative_flag;
    
    genvar idx_0_1939020140;
    
    generate
        for (idx_0_1939020140 = 0; idx_0_1939020140 < _MP_SIZE_1939020140; idx_0_1939020140 = idx_0_1939020140 + 1) begin: forLoop_idx_0_1939020140
            adder #(
                .SIZE(_MP_SIZE_1939020140)
            ) adder (
                .a(M_adder_a[idx_0_1939020140]),
                .b(M_adder_b[idx_0_1939020140]),
                .alufn(M_adder_alufn[idx_0_1939020140]),
                .out(M_adder_out[idx_0_1939020140]),
                .zero_flag(M_adder_zero_flag[idx_0_1939020140]),
                .overflow_flag(M_adder_overflow_flag[idx_0_1939020140]),
                .negative_flag(M_adder_negative_flag[idx_0_1939020140])
            );
        end
    endgenerate
    
    
    localparam _MP_SIZE_1172765164 = 2'h2 * SIZE;
    logic [(_MP_SIZE_1172765164)-1:0][(_MP_SIZE_1172765164)-1:0] M_shiftR_a;
    logic [(_MP_SIZE_1172765164)-1:0][4:0] M_shiftR_shift;
    logic [(_MP_SIZE_1172765164)-1:0][(_MP_SIZE_1172765164)-1:0] M_shiftR_result;
    
    genvar idx_0_1172765164;
    
    generate
        for (idx_0_1172765164 = 0; idx_0_1172765164 < _MP_SIZE_1172765164; idx_0_1172765164 = idx_0_1172765164 + 1) begin: forLoop_idx_0_1172765164
            shifter_ArithBitR #(
                .SIZE(_MP_SIZE_1172765164)
            ) shiftR (
                .a(M_shiftR_a[idx_0_1172765164]),
                .shift(M_shiftR_shift[idx_0_1172765164]),
                .result(M_shiftR_result[idx_0_1172765164])
            );
        end
    endgenerate
    
    
    always @* begin
        for (RR_5ee2e4f0_i = 0; RR_5ee2e4f0_i < SIZE; RR_5ee2e4f0_i = RR_5ee2e4f0_i + 1) begin
      R_5ee2e4f0_i = (0) + RR_5ee2e4f0_i * (1);
            M_adder_a[R_5ee2e4f0_i] = 1'h0;
            M_adder_b[R_5ee2e4f0_i] = 1'h0;
            M_adder_alufn[R_5ee2e4f0_i] = 1'h0;
            M_shiftR_a[R_5ee2e4f0_i] = 1'h0;
            M_shiftR_shift[R_5ee2e4f0_i] = 1'h0;
            accum[R_5ee2e4f0_i] = 1'h0;
            up_half[R_5ee2e4f0_i] = 1'h0;
            low_half[R_5ee2e4f0_i] = 1'h0;
            old_lsb[R_5ee2e4f0_i] = 1'h0;
            temp_accum[R_5ee2e4f0_i] = 1'h0;
        end
        accum[1'h0] = {{SIZE{1'h0}}, a};
        old_lsb[1'h0] = 1'h0;
        for (RR_7ff2230f_i = 0; RR_7ff2230f_i < SIZE; RR_7ff2230f_i = RR_7ff2230f_i + 1) begin
      R_7ff2230f_i = (0) + RR_7ff2230f_i * (1);
            if (accum[R_7ff2230f_i][1'h0] == 1'h0 && old_lsb[R_7ff2230f_i] == 1'h1) begin
                M_adder_a[R_7ff2230f_i] = accum[R_7ff2230f_i][2'h2 * SIZE - 1'h1:SIZE];
                M_adder_b[R_7ff2230f_i] = b;
                up_half[R_7ff2230f_i] = M_adder_out[R_7ff2230f_i];
            end else begin
                if (accum[R_7ff2230f_i][1'h0] == 1'h1 && old_lsb[R_7ff2230f_i] == 1'h0) begin
                    M_adder_a[R_7ff2230f_i] = accum[R_7ff2230f_i][2'h2 * SIZE - 1'h1:SIZE];
                    M_adder_b[R_7ff2230f_i] = b;
                    M_adder_alufn[R_7ff2230f_i] = 1'h1;
                    up_half[R_7ff2230f_i] = M_adder_out[R_7ff2230f_i];
                end else begin
                    up_half[R_7ff2230f_i] = accum[R_7ff2230f_i][2'h2 * SIZE - 1'h1:SIZE];
                end
            end
            low_half[R_7ff2230f_i] = accum[R_7ff2230f_i][SIZE - 1'h1:1'h0];
            temp_accum[R_7ff2230f_i] = {up_half[R_7ff2230f_i], low_half[R_7ff2230f_i]};
            M_shiftR_a[R_7ff2230f_i] = temp_accum[R_7ff2230f_i];
            M_shiftR_shift[R_7ff2230f_i] = 1'h1;
            if (R_7ff2230f_i < SIZE - 1'h1) begin
                old_lsb[R_7ff2230f_i + 1'h1] = accum[R_7ff2230f_i][1'h0];
                accum[R_7ff2230f_i + 1'h1] = M_shiftR_result[R_7ff2230f_i];
            end else begin
                if (R_7ff2230f_i == SIZE - 1'h1) begin
                    final_accum = M_shiftR_result[R_7ff2230f_i];
                end
            end
        end
        out = alufn ? final_accum[SIZE - 1'h1:1'h0] : 1'h0;
    end
    
    
endmodule